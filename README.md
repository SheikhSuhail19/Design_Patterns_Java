# Design Patterns

⭐Creational Design Patterns

◾Singleton Pattern

-Ensure a class has only one instance and provide a global point of access to it.

◾Factory Method Pattern

-Define an interface for creating an object but let subclasses alter the type of objects that will be created.

◾Builder Pattern

-Separate the construction of a complex object from its representation so that the same construction process can create different representations.

◾Prototype Pattern

-Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.

⭐Structural Design Patterns

◾Adapter Pattern

-Convert the interface of a class into another interface clients expect.

-Classes work together that couldn't otherwise because of incompatible interfaces.

◾Bridge Pattern

-Decouple an abstraction from its implementation so that the two can vary independently.

-Avoid permanent binding between an abstraction & its implementation.

◾Composite Pattern

-Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.

◾Decorator Pattern

-Attach additional responsibilities to an object dynamically.

-When you want to add or alter the behavior of objects without altering their code.

◾Facade Pattern

-Provide a unified interface to a set of interfaces in a subsystem.

-Facade defines a higher-level interface that makes the subsystem easier to use.

◾Flyweight Pattern

-Use sharing to support a large number of fine-grained objects efficiently.

◾Proxy Pattern

-Provide a surrogate or placeholder for another object to control access to it.

⭐ Behavioral Design Patterns

◾Chain of Responsibility Pattern

-Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.

◾ Command Pattern

-Encapsulate a request as an object, thereby parameterizing clients with queues, requests, and operations.

-When you want to decouple the sender and receiver of a request.

◾Mediator Pattern

-Define an object that encapsulates how a set of objects interact.

-Mediator promotes loose coupling by keeping objects from referring to each other explicitly.

◾Observer Pattern

-Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

◾State Pattern

-Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.

◾Strategy Pattern

-Define a family of algorithms, encapsulate each one, and make them interchangeable.

-Strategy lets the algorithm vary independently from clients that use it.
